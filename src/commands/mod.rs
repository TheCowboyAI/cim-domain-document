//! Document domain commands

use cim_domain::Command as DomainCommand;
use cim_domain::EntityId;
use crate::aggregate::{
    DocumentInfoComponent, ConfidentialityLevel,
};
use uuid::Uuid;
use cid::Cid;
use serde::{Deserialize, Serialize};
use crate::value_objects::DocumentMetadata;

/// Trait for document commands
pub trait Command: Send + Sync + std::fmt::Debug {}

/// Upload a new document
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UploadDocument {
    /// Document's unique ID (generated by caller)
    pub document_id: Uuid,
    /// Document information
    pub info: DocumentInfoComponent,
    /// Content CID from object store
    pub content_cid: Cid,
    /// Whether the document is chunked
    pub is_chunked: bool,
    /// Chunk CIDs if chunked
    pub chunk_cids: Vec<Cid>,
    /// Who is uploading the document
    pub uploaded_by: Uuid,
}

impl DomainCommand for UploadDocument {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.document_id))
    }
}

impl Command for UploadDocument {}

/// Classify a document
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClassifyDocument {
    /// The ID of the document to classify
    pub document_id: Uuid,
    /// Document type
    pub document_type: String,
    /// Business category
    pub category: String,
    /// Subcategories
    pub subcategories: Vec<String>,
    /// Tags
    pub tags: Vec<String>,
    /// Confidentiality level
    pub confidentiality: ConfidentialityLevel,
    /// Who is classifying
    pub classified_by: Uuid,
}

impl DomainCommand for ClassifyDocument {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.document_id))
    }
}

impl Command for ClassifyDocument {}

/// Create a new document
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateDocument {
    /// Document's unique ID (generated by caller)
    pub document_id: crate::value_objects::DocumentId,
    /// Document type
    pub document_type: crate::value_objects::DocumentType,
    /// Document title
    pub title: String,
    /// Author ID
    pub author_id: Uuid,
    /// Initial metadata
    pub metadata: std::collections::HashMap<String, String>,
}

impl DomainCommand for CreateDocument {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(*self.document_id.as_uuid()))
    }
}

impl Command for CreateDocument {}

/// Update document content
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateContent {
    /// Document ID
    pub document_id: crate::value_objects::DocumentId,
    /// Content blocks to update/add
    pub content_blocks: Vec<crate::value_objects::ContentBlock>,
    /// Change summary
    pub change_summary: String,
    /// Updated by
    pub updated_by: Uuid,
}

impl DomainCommand for UpdateContent {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(*self.document_id.as_uuid()))
    }
}

impl Command for UpdateContent {}

/// Share document with users
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ShareDocument {
    /// Document ID
    pub document_id: crate::value_objects::DocumentId,
    /// User ID to share with
    pub share_with: Uuid,
    /// Access level
    pub access_level: crate::value_objects::AccessLevel,
    /// Shared by
    pub shared_by: Uuid,
}

impl DomainCommand for ShareDocument {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(*self.document_id.as_uuid()))
    }
}

impl Command for ShareDocument {}

/// Change document state
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChangeState {
    /// Document ID
    pub document_id: crate::value_objects::DocumentId,
    /// New state
    pub new_state: crate::value_objects::DocumentState,
    /// Reason for state change
    pub reason: String,
    /// Changed by
    pub changed_by: Uuid,
}

impl DomainCommand for ChangeState {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(*self.document_id.as_uuid()))
    }
}

impl Command for ChangeState {}

/// Update document metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateDocumentMetadata {
    /// The ID of the document to update
    pub document_id: Uuid,
    /// New metadata
    pub metadata: DocumentMetadata,
    /// Who is updating
    pub updated_by: String,
}

impl DomainCommand for UpdateDocumentMetadata {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.document_id))
    }
}

impl Command for UpdateDocumentMetadata {}

/// Archive a document
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ArchiveDocument {
    /// The ID of the document to archive
    pub document_id: Uuid,
    /// Reason for archiving
    pub reason: String,
    /// Retention period in days
    pub retention_days: Option<u32>,
    /// Who is archiving
    pub archived_by: Uuid,
}

impl DomainCommand for ArchiveDocument {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.document_id))
    }
}

impl Command for ArchiveDocument {}
