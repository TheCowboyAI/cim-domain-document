//! Document domain commands

use cim_domain::Command as DomainCommand;
use cim_domain::EntityId;
use crate::aggregate::{
    DocumentInfoComponent, ConfidentialityLevel,
};
use uuid::Uuid;
use cid::Cid;
use serde::{Deserialize, Serialize};
use crate::value_objects::DocumentMetadata;

/// Trait for document commands
pub trait Command: Send + Sync + std::fmt::Debug {}

/// Upload a new document
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UploadDocument {
    /// Document's unique ID (generated by caller)
    pub document_id: Uuid,
    /// Document information
    pub info: DocumentInfoComponent,
    /// Content CID from object store
    pub content_cid: Cid,
    /// Whether the document is chunked
    pub is_chunked: bool,
    /// Chunk CIDs if chunked
    pub chunk_cids: Vec<Cid>,
    /// Who is uploading the document
    pub uploaded_by: Uuid,
}

impl DomainCommand for UploadDocument {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.document_id))
    }
}

impl Command for UploadDocument {}

/// Classify a document
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClassifyDocument {
    /// The ID of the document to classify
    pub document_id: Uuid,
    /// Document type
    pub document_type: String,
    /// Business category
    pub category: String,
    /// Subcategories
    pub subcategories: Vec<String>,
    /// Tags
    pub tags: Vec<String>,
    /// Confidentiality level
    pub confidentiality: ConfidentialityLevel,
    /// Who is classifying
    pub classified_by: Uuid,
}

impl DomainCommand for ClassifyDocument {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.document_id))
    }
}

impl Command for ClassifyDocument {}

/// Create a new document
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateDocument {
    /// Document's unique ID (generated by caller)
    pub document_id: crate::value_objects::DocumentId,
    /// Document type
    pub document_type: crate::value_objects::DocumentType,
    /// Document title
    pub title: String,
    /// Author ID
    pub author_id: Uuid,
    /// Initial metadata
    pub metadata: std::collections::HashMap<String, String>,
}

impl DomainCommand for CreateDocument {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(*self.document_id.as_uuid()))
    }
}

impl Command for CreateDocument {}

/// Update document content
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateContent {
    /// Document ID
    pub document_id: crate::value_objects::DocumentId,
    /// Content blocks to update/add
    pub content_blocks: Vec<crate::value_objects::ContentBlock>,
    /// Change summary
    pub change_summary: String,
    /// Updated by
    pub updated_by: Uuid,
}

impl DomainCommand for UpdateContent {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(*self.document_id.as_uuid()))
    }
}

impl Command for UpdateContent {}

/// Share document with users
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ShareDocument {
    /// Document ID
    pub document_id: crate::value_objects::DocumentId,
    /// User ID to share with
    pub share_with: Uuid,
    /// Access level
    pub access_level: crate::value_objects::AccessLevel,
    /// Shared by
    pub shared_by: Uuid,
}

impl DomainCommand for ShareDocument {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(*self.document_id.as_uuid()))
    }
}

impl Command for ShareDocument {}

/// Change document state
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChangeState {
    /// Document ID
    pub document_id: crate::value_objects::DocumentId,
    /// New state
    pub new_state: crate::value_objects::DocumentState,
    /// Reason for state change
    pub reason: String,
    /// Changed by
    pub changed_by: Uuid,
}

impl DomainCommand for ChangeState {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(*self.document_id.as_uuid()))
    }
}

impl Command for ChangeState {}

/// Update document metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateDocumentMetadata {
    /// The ID of the document to update
    pub document_id: Uuid,
    /// New metadata
    pub metadata: DocumentMetadata,
    /// Who is updating
    pub updated_by: String,
}

impl DomainCommand for UpdateDocumentMetadata {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.document_id))
    }
}

impl Command for UpdateDocumentMetadata {}

/// Archive a document
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ArchiveDocument {
    /// The ID of the document to archive
    pub document_id: Uuid,
    /// Reason for archiving
    pub reason: String,
    /// Retention period in days
    pub retention_days: Option<u32>,
    /// Who is archiving
    pub archived_by: Uuid,
}

impl DomainCommand for ArchiveDocument {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.document_id))
    }
}

impl Command for ArchiveDocument {}

/// Fork a document
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ForkDocument {
    /// The ID of the document to fork
    pub document_id: crate::value_objects::DocumentId,
    /// New document ID for the fork
    pub fork_id: crate::value_objects::DocumentId,
    /// Fork description
    pub description: String,
    /// Who is forking
    pub forked_by: Uuid,
}

impl DomainCommand for ForkDocument {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(*self.document_id.as_uuid()))
    }
}

impl Command for ForkDocument {}

/// Tag a document version
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TagVersion {
    /// Document ID
    pub document_id: crate::value_objects::DocumentId,
    /// Tag name
    pub tag_name: String,
    /// Tag description
    pub description: Option<String>,
    /// Who is tagging
    pub tagged_by: Uuid,
}

impl DomainCommand for TagVersion {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(*self.document_id.as_uuid()))
    }
}

impl Command for TagVersion {}

/// Add a comment to a document
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AddComment {
    /// Document ID
    pub document_id: crate::value_objects::DocumentId,
    /// Comment content
    pub content: String,
    /// Optional reference to specific content block
    pub block_id: Option<String>,
    /// Parent comment ID for threads
    pub parent_comment_id: Option<Uuid>,
    /// Comment author
    pub author_id: Uuid,
}

impl DomainCommand for AddComment {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(*self.document_id.as_uuid()))
    }
}

impl Command for AddComment {}

/// Link related documents
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LinkDocuments {
    /// Source document ID
    pub source_id: crate::value_objects::DocumentId,
    /// Target document ID
    pub target_id: crate::value_objects::DocumentId,
    /// Link type
    pub link_type: crate::value_objects::LinkType,
    /// Link description
    pub description: Option<String>,
    /// Who is creating the link
    pub linked_by: Uuid,
}

impl DomainCommand for LinkDocuments {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(*self.source_id.as_uuid()))
    }
}

impl Command for LinkDocuments {}

/// Merge changes from a forked document
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MergeDocuments {
    /// Target document ID (merge into)
    pub target_id: crate::value_objects::DocumentId,
    /// Source document ID (merge from)
    pub source_id: crate::value_objects::DocumentId,
    /// Merge strategy
    pub strategy: crate::value_objects::MergeStrategy,
    /// Conflict resolution
    pub conflict_resolution: crate::value_objects::ConflictResolution,
    /// Who is performing the merge
    pub merged_by: Uuid,
}

impl DomainCommand for MergeDocuments {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(*self.target_id.as_uuid()))
    }
}

impl Command for MergeDocuments {}

/// Rollback to a previous version
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RollbackVersion {
    /// Document ID
    pub document_id: crate::value_objects::DocumentId,
    /// Version to rollback to
    pub target_version: crate::value_objects::DocumentVersion,
    /// Reason for rollback
    pub reason: String,
    /// Who is performing the rollback
    pub rolled_back_by: Uuid,
}

impl DomainCommand for RollbackVersion {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(*self.document_id.as_uuid()))
    }
}

impl Command for RollbackVersion {}

/// Extract entities from document content
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExtractEntities {
    /// Document ID
    pub document_id: crate::value_objects::DocumentId,
    /// Extraction options
    pub options: crate::value_objects::ExtractionOptions,
    /// Who requested extraction
    pub requested_by: Uuid,
}

impl DomainCommand for ExtractEntities {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(*self.document_id.as_uuid()))
    }
}

impl Command for ExtractEntities {}

/// Generate document summary
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GenerateSummary {
    /// Document ID
    pub document_id: crate::value_objects::DocumentId,
    /// Summary length
    pub length: crate::value_objects::SummaryLength,
    /// Language for summary
    pub language: Option<String>,
    /// Who requested summary
    pub requested_by: Uuid,
}

impl DomainCommand for GenerateSummary {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(*self.document_id.as_uuid()))
    }
}

impl Command for GenerateSummary {}

/// Apply a template to a document
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ApplyTemplate {
    /// Document ID
    pub document_id: crate::value_objects::DocumentId,
    /// Template ID to apply
    pub template_id: crate::value_objects::TemplateId,
    /// Variable values for substitution
    pub variables: std::collections::HashMap<String, String>,
    /// Who is applying the template
    pub applied_by: Uuid,
}

impl DomainCommand for ApplyTemplate {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(*self.document_id.as_uuid()))
    }
}

impl Command for ApplyTemplate {}

/// Create a document collection
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateCollection {
    /// Collection ID
    pub collection_id: Uuid,
    /// Collection name
    pub name: String,
    /// Collection description
    pub description: Option<String>,
    /// Parent collection ID for hierarchy
    pub parent_id: Option<Uuid>,
    /// Collection metadata
    pub metadata: std::collections::HashMap<String, String>,
    /// Who is creating the collection
    pub created_by: Uuid,
}

impl DomainCommand for CreateCollection {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        None // Collections are separate from individual documents
    }
}

impl Command for CreateCollection {}

/// Add document to collection
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AddToCollection {
    /// Document ID
    pub document_id: crate::value_objects::DocumentId,
    /// Collection ID
    pub collection_id: Uuid,
    /// Who is adding to collection
    pub added_by: Uuid,
}

impl DomainCommand for AddToCollection {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(*self.document_id.as_uuid()))
    }
}

impl Command for AddToCollection {}

/// Import external document
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ImportDocument {
    /// New document ID
    pub document_id: crate::value_objects::DocumentId,
    /// Source format
    pub source_format: crate::value_objects::ImportFormat,
    /// Content to import
    pub content: Vec<u8>,
    /// Import options
    pub options: crate::value_objects::ImportOptions,
    /// Who is importing
    pub imported_by: Uuid,
}

impl DomainCommand for ImportDocument {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(*self.document_id.as_uuid()))
    }
}

impl Command for ImportDocument {}

/// Export document
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExportDocument {
    /// Document ID
    pub document_id: crate::value_objects::DocumentId,
    /// Target format
    pub target_format: crate::value_objects::ExportFormat,
    /// Export options
    pub options: crate::value_objects::ExportOptions,
    /// Who is exporting
    pub exported_by: Uuid,
}

impl DomainCommand for ExportDocument {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(*self.document_id.as_uuid()))
    }
}

impl Command for ExportDocument {}
