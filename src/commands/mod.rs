//! Document commands

use cim_domain::Command;
use cim_domain::EntityId;
use crate::aggregate::{
    DocumentMarker, DocumentInfoComponent, ConfidentialityLevel,
    DocumentStatus, DocumentRelation, ExternalReference,
};
use uuid::Uuid;
use cid::Cid;
use serde::{Deserialize, Serialize};
use std::collections::HashSet;

/// Upload a new document
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UploadDocument {
    /// Document's unique ID (generated by caller)
    pub document_id: Uuid,
    /// Document information
    pub info: DocumentInfoComponent,
    /// Content CID from object store
    pub content_cid: Cid,
    /// Whether the document is chunked
    pub is_chunked: bool,
    /// Chunk CIDs if chunked
    pub chunk_cids: Vec<Cid>,
    /// Who is uploading the document
    pub uploaded_by: Uuid,
}

impl Command for UploadDocument {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.document_id))
    }
}

/// Classify a document
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClassifyDocument {
    /// The ID of the document to classify
    pub document_id: Uuid,
    /// Document type
    pub document_type: String,
    /// Business category
    pub category: String,
    /// Subcategories
    pub subcategories: Vec<String>,
    /// Tags
    pub tags: Vec<String>,
    /// Confidentiality level
    pub confidentiality: ConfidentialityLevel,
    /// Who is classifying
    pub classified_by: Uuid,
}

impl Command for ClassifyDocument {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.document_id))
    }
}

/// Assign document ownership
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AssignDocumentOwnership {
    /// The ID of the document
    pub document_id: Uuid,
    /// New owner ID
    pub owner_id: Uuid,
    /// Author IDs
    pub authors: Vec<Uuid>,
    /// Department
    pub department: Option<String>,
    /// Project ID
    pub project_id: Option<Uuid>,
    /// Who is assigning ownership
    pub assigned_by: Uuid,
}

impl Command for AssignDocumentOwnership {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.document_id))
    }
}

/// Set document access control
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetDocumentAccessControl {
    /// The ID of the document
    pub document_id: Uuid,
    /// Read access list
    pub read_access: Vec<Uuid>,
    /// Write access list
    pub write_access: Vec<Uuid>,
    /// Share access list
    pub share_access: Vec<Uuid>,
    /// Enable audit logging
    pub audit_access: bool,
    /// Who is setting access control
    pub set_by: Uuid,
}

impl Command for SetDocumentAccessControl {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.document_id))
    }
}

/// Set document status
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetDocumentStatus {
    /// The ID of the document
    pub document_id: Uuid,
    /// New status
    pub status: DocumentStatus,
    /// Reason for status change
    pub reason: Option<String>,
    /// Who is changing the status
    pub changed_by: Uuid,
}

impl Command for SetDocumentStatus {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.document_id))
    }
}

/// Process document (extract text, generate thumbnails, etc.)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProcessDocument {
    /// The ID of the document to process
    pub document_id: Uuid,
    /// Extract text
    pub extract_text: bool,
    /// Perform OCR if needed
    pub perform_ocr: bool,
    /// Generate thumbnails
    pub generate_thumbnails: bool,
    /// Index for search
    pub index_document: bool,
    /// Who requested processing
    pub requested_by: Uuid,
}

impl Command for ProcessDocument {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.document_id))
    }
}

/// Add document relationship
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AddDocumentRelationship {
    /// The ID of the document
    pub document_id: Uuid,
    /// Related document
    pub related_document: DocumentRelation,
    /// Who is adding the relationship
    pub added_by: Uuid,
}

impl Command for AddDocumentRelationship {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.document_id))
    }
}

/// Remove document relationship
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RemoveDocumentRelationship {
    /// The ID of the document
    pub document_id: Uuid,
    /// Related document ID to remove
    pub related_document_id: Uuid,
    /// Who is removing the relationship
    pub removed_by: Uuid,
}

impl Command for RemoveDocumentRelationship {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.document_id))
    }
}

/// Create a new version of a document
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateDocumentVersion {
    /// The ID of the document
    pub document_id: Uuid,
    /// New version number
    pub version_number: String,
    /// New content CID
    pub content_cid: Cid,
    /// Changes description
    pub changes_description: String,
    /// Who is creating the version
    pub created_by: Uuid,
}

impl Command for CreateDocumentVersion {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.document_id))
    }
}

/// Archive a document
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ArchiveDocument {
    /// The ID of the document to archive
    pub document_id: Uuid,
    /// Reason for archiving
    pub reason: String,
    /// Retention period in days
    pub retention_days: Option<u32>,
    /// Who is archiving
    pub archived_by: Uuid,
}

impl Command for ArchiveDocument {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.document_id))
    }
}
